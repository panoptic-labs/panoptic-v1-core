// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.24;

// Interfaces
import {PanopticPool} from "./PanopticPool.sol";
// Inherited implementations
import {Clone} from "clones-with-immutable-args/Clone.sol";
import {ERC20Minimal} from "@tokens/ERC20Minimal.sol";
import {Multicall} from "@base/Multicall.sol";
// Libraries
import {Constants} from "@libraries/Constants.sol";
import {Errors} from "@libraries/Errors.sol";
import {InteractionHelper} from "@libraries/InteractionHelper.sol";
import {Math} from "@libraries/Math.sol";
import {PanopticMath} from "@libraries/PanopticMath.sol";
import {SafeTransferLib} from "@libraries/SafeTransferLib.sol";
// Custom types
import {LeftRightUnsigned, LeftRightSigned} from "@types/LeftRight.sol";
import {LiquidityChunk} from "@types/LiquidityChunk.sol";
import {PositionBalance} from "@types/PositionBalance.sol";
import {TokenId} from "@types/TokenId.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {Currency} from "v4-core/types/Currency.sol";

/// @title Collateral Tracking System / Margin Accounting used in conjunction with a Panoptic Pool.
/// @author Axicon Labs Limited
//
/// @notice Tracks collateral of users which is key to ensure the correct level of collateralization is achieved.
/// This is represented as an ERC20 share token. A Panoptic pool has 2 tokens, each issued by its own instance of a CollateralTracker.
/// All math within this contract pertains to a single token.
//
/// @notice This contract uses the ERC4626 standard allowing the minting and burning of "shares" (represented using ERC20 inheritance) in exchange for underlying "assets".
/// Panoptic uses a collateral tracking system that is similar to TradFi margin accounts. While users can borrow and
/// effectively control funds several times larger than the collateral they deposited, they cannot withdraw those funds
/// from the Panoptic-Uniswap ecosystem. All funds are always owned by the Panoptic protocol, but users will:
//
/// @notice 1) collect any fees generated by selling an option.
//
/// @notice 2) get any gain in capital that results from buying an option that becomes in-the-money.
contract CollateralTracker is Clone, ERC20Minimal, Multicall {
    using Math for uint256;

    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when assets are deposited into the Collateral Tracker.
    /// @param sender The address of the caller (and depositor)
    /// @param owner The address of the recipient of the newly minted shares
    /// @param assets The amount of assets deposited by `sender` in exchange for `shares`
    /// @param shares The amount of shares minted to `owner`
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);

    /// @notice Emitted when assets are withdrawn from the Collateral Tracker.
    /// @param sender The address of the caller
    /// @param receiver The address of the recipient of the withdrawn assets
    /// @param owner The address of the owner of the shares being burned
    /// @param assets The amount of assets withdrawn to `receiver`
    /// @param shares The amount of shares burned by `owner` in exchange for `assets`
    event Withdraw(
        address indexed sender,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /*//////////////////////////////////////////////////////////////
                               CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Prefix for the token symbol (i.e. poUSDC).
    string internal constant TICKER_PREFIX = "po";

    /// @notice Prefix for the token name (i.e POPT-V1.1 USDC LP on ETH/USDC 30bps).
    string internal constant NAME_PREFIX = "POPT-V1.1";

    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
    /// @dev uint type for composability with unsigned integer based mathematical operations.
    uint256 internal constant DECIMALS = 10_000;

    /// @notice Decimals for computation (1 bps (basis point) precision: 0.01%).
    /// @dev int type for composability with signed integer based mathematical operations.
    int128 internal constant DECIMALS_128 = 10_000;

    /*//////////////////////////////////////////////////////////////
                            RISK PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @notice The commission fee, in basis points, collected from PLPs at option mint.
    /// @dev In Panoptic, options never expire, commissions are only paid when a new position is minted.
    /// @dev We believe that this will eliminate the impact of the commission fee on the user's decision-making process when closing a position.
    uint256 immutable COMMISSION_FEE;

    // base collateral ratios

    /// @notice Required collateral ratios for buying, represented as percentage * 10_000.
    /// @dev i.e 20% -> 0.2 * 10_000 = 2_000.
    uint256 immutable SELLER_COLLATERAL_RATIO;

    /// @notice Required collateral ratios for selling, represented as percentage * 10_000.
    /// @dev i.e 10% -> 0.1 * 10_000 = 1_000.
    uint256 immutable BUYER_COLLATERAL_RATIO;

    // miscellaneous parameters

    /// @notice Basal cost (in bps of notional) to force exercise a position that is barely far-the-money (out-of-range).
    int256 immutable FORCE_EXERCISE_COST;

    // Targets a pool utilization (balance between buying and selling)
    /// @notice Target pool utilization below which buying+selling is optimal, represented as percentage * 10_000.
    /// @dev i.e 50% -> 0.5 * 10_000 = 5_000.
    uint256 immutable TARGET_POOL_UTIL;

    /// @notice Pool utilization above which selling is 100% collateral backed, represented as percentage * 10_000.
    /// @dev i.e 90% -> 0.9 * 10_000 = 9_000.
    uint256 immutable SATURATED_POOL_UTIL;

    /// @notice Fee, in basis points, that is charged on the intrinsic value of ITM positions.
    uint256 immutable ITM_SPREAD_FEE;

    /// @notice The canonical Uniswap V4 Pool Manager address.
    IPoolManager internal immutable POOL_MANAGER_V4;

    /*//////////////////////////////////////////////////////////////
                         POOL UTILIZATION DATA
    //////////////////////////////////////////////////////////////*/

    /// @notice Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes.
    uint128 internal s_poolAssets;

    /// @notice Amount of assets moved from the Panoptic Pool to the AMM.
    uint128 internal s_inAMM;

    /*//////////////////////////////////////////////////////////////
                          INITIALIZATION STATE
    //////////////////////////////////////////////////////////////*/

    /// @notice Boolean tracking whether this CollateralTracker has been initialized.
    bool internal s_initialized;

    /*//////////////////////////////////////////////////////////////
                   POOL-SPECIFIC IMMUTABLE PARAMETERS
    //////////////////////////////////////////////////////////////*/

    // The parameters will be encoded at `_getImmutableArgsOffset()` in calldata as follows:
    // abi.encodePacked(address panopticPool, bool underlyingIsToken0, address underlyingToken, address token0, address token1, uint24 poolFee)
    // bytes: 0                    20                 21                   41                   61                   81
    //        |<---- 160 bits ---->|<---- 8 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 24 bits ---->|
    //             panopticPool     underlyingIsToken0    underlyingToken          token0               token1              poolFee

    /// @notice Retrieve the Panoptic Pool that this collateral token belongs to.
    /// @return The Panoptic Pool associated with this collateral token
    function _panopticPool() internal pure returns (PanopticPool) {
        return PanopticPool(_getArgAddress(0));
    }

    /// @notice Retrieve a boolean indicating whether the underlying token is token0 or token1 in the Uniswap V4 pool.
    /// @return underlyingIsToken0 True if the underlying token is token0, false if it is token1
    function _underlyingIsToken0() internal pure returns (bool underlyingIsToken0) {
        uint256 offset = _getImmutableArgsOffset();

        assembly ("memory-safe") {
            underlyingIsToken0 := shr(0xf8, calldataload(add(offset, 20)))
        }
    }

    /// @notice Retrieve the address of the underlying token.
    /// @return The address of the underlying token
    function _underlyingToken() internal pure returns (address) {
        return _getArgAddress(21);
    }

    /// @notice Retrieve the address of token0 in the Uniswap V4 pool.
    /// @return The address of token0 in the Uniswap V4 pool
    function _token0() internal pure returns (address) {
        return _getArgAddress(41);
    }

    /// @notice Retrieve the address of token1 in the Uniswap V4 pool.
    /// @return The address of token1 in the Uniswap V4 pool
    function _token1() internal pure returns (address) {
        return _getArgAddress(61);
    }

    /// @notice Retrieve the fee of the Uniswap V4 pool.
    /// @return poolFee The fee of the Uniswap V4 pool
    function _poolFee() internal pure returns (uint24 poolFee) {
        uint256 offset = _getImmutableArgsOffset();

        assembly ("memory-safe") {
            poolFee := shr(0xe8, calldataload(add(offset, 81)))
        }
    }

    /*//////////////////////////////////////////////////////////////
                            ACCESS CONTROL
    //////////////////////////////////////////////////////////////*/

    /// @notice Ensure that the associated Panoptic pool is the caller. Revert if not.
    modifier onlyPanopticPool() {
        if (msg.sender != address(_panopticPool())) revert Errors.NotPanopticPool();
        _;
    }

    /*//////////////////////////////////////////////////////////////
                  INITIALIZATION & PARAMETER SETTINGS
    //////////////////////////////////////////////////////////////*/

    /// @notice Set immutable parameters for the Collateral Tracker.
    /// @param _commissionFee The commission fee, in basis points, collected from PLPs at option mint
    /// @param _sellerCollateralRatio Required collateral ratios for buying, represented as percentage * 10_000
    /// @param _buyerCollateralRatio Required collateral ratios for selling, represented as percentage * 10_000
    /// @param _forceExerciseCost Basal cost (in bps of notional) to force exercise a position that is barely far-the-money (out-of-range)
    /// @param _targetPoolUtilization Target pool utilization below which buying+selling is optimal, represented as percentage * 10_000
    /// @param _saturatedPoolUtilization Pool utilization above which selling is 100% collateral backed, represented as percentage * 10_000
    /// @param _ITMSpreadFee Fee, in basis points, that is charged on the intrinsic value of ITM positions
    /// @param _manager The canonical Uniswap V4 pool manager
    constructor(
        uint256 _commissionFee,
        uint256 _sellerCollateralRatio,
        uint256 _buyerCollateralRatio,
        int256 _forceExerciseCost,
        uint256 _targetPoolUtilization,
        uint256 _saturatedPoolUtilization,
        uint256 _ITMSpreadFee,
        IPoolManager _manager
    ) {
        COMMISSION_FEE = _commissionFee;
        SELLER_COLLATERAL_RATIO = _sellerCollateralRatio;
        BUYER_COLLATERAL_RATIO = _buyerCollateralRatio;
        FORCE_EXERCISE_COST = _forceExerciseCost;
        TARGET_POOL_UTIL = _targetPoolUtilization;
        SATURATED_POOL_UTIL = _saturatedPoolUtilization;
        ITM_SPREAD_FEE = _ITMSpreadFee;
        POOL_MANAGER_V4 = _manager;
    }

    /// @notice Initializes a new `CollateralTracker` instance with 1 virtual asset and 10^6 virtual shares.
    function initialize() external {
        if (s_initialized) revert Errors.CollateralTokenAlreadyInitialized();
        s_initialized = true;

        // these virtual shares function as a multiplier for the capital requirement to manipulate the pool price
        // e.g. if the virtual shares are 10**6, then the capital requirement to manipulate the price to 10**12 is 10**18
        totalSupply = 10 ** 6;

        // set total assets to 1
        // the initial share price is defined by 1/virtualShares
        s_poolAssets = 1;
    }

    /*//////////////////////////////////////////////////////////////
                        COLLATERAL TOKEN INFORMATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Get information about the utilization of this collateral vault.
    /// @return poolAssets Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes
    /// @return insideAMM The underlying token amount held in the AMM
    /// @return currentPoolUtilization The pool utilization defined as`s_inAMM * 10_000 / totalAssets()`,
    /// where totalAssets is the total tracked assets in the AMM and PanopticPool minus fees and donations to the Panoptic pool
    function getPoolData()
        external
        view
        returns (uint256 poolAssets, uint256 insideAMM, uint256 currentPoolUtilization)
    {
        poolAssets = s_poolAssets;
        insideAMM = s_inAMM;
        currentPoolUtilization = _poolUtilization();
    }

    /// @notice Returns name of token composed of underlying token symbol and pool data.
    /// @return The name of the token
    function name() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return
            InteractionHelper.computeName(
                _token0(),
                _token1(),
                _underlyingIsToken0(),
                _poolFee(),
                NAME_PREFIX
            );
    }

    /// @notice Returns symbol as prefixed symbol of underlying token.
    /// @return The symbol of the token
    function symbol() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeSymbol(_underlyingToken(), TICKER_PREFIX);
    }

    /// @notice Returns decimals of underlying token (0 if not present).
    /// @return The decimals of the token
    function decimals() external view returns (uint8) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeDecimals(_underlyingToken());
    }

    /*//////////////////////////////////////////////////////////////
                     LIMITED TRANSFER FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @dev See {IERC20-transfer}.
    /// Requirements:
    /// - the caller must have a balance of at least `amount`.
    /// - the msg.sender must not have any position on the panoptic pool
    function transfer(
        address recipient,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        // make sure the caller does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // as this would reduce their amount of collateral against the opened positions

        if (_panopticPool().numberOfPositions(msg.sender) != 0)
            revert Errors.PositionCountNotZero();

        return ERC20Minimal.transfer(recipient, amount);
    }

    /// @dev See {IERC20-transferFrom}.
    /// Requirements:
    /// - the `from` must have a balance of at least `amount`.
    /// - the caller must have allowance for `from` of at least `amount` tokens.
    /// - `from` must not have any open positions on the panoptic pool.
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        // make sure the caller does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // as this would reduce their amount of collateral against the opened positions

        if (_panopticPool().numberOfPositions(from) != 0) revert Errors.PositionCountNotZero();

        return ERC20Minimal.transferFrom(from, to, amount);
    }

    /*//////////////////////////////////////////////////////////////
                        UNISWAP V4 LOCK CALLBACK
    //////////////////////////////////////////////////////////////*/

    /// @notice Initiates the unlock callback to wrap/unwrap `delta` amount of the underlying token and transfer to/from the Panoptic Pool.
    /// @param account The address of the account to transfer the underlying token to/from
    /// @param delta The amount of the underlying token to wrap/unwrap and transfer
    function _settleTokenDelta(address account, int256 delta) internal {
        POOL_MANAGER_V4.unlock(abi.encode(account, delta));
    }

    /// @notice Uniswap V4 unlock callback implementation.
    /// @dev Parameters are `(address account, int256 delta)`.
    /// @dev Wraps/unwraps `delta` amount of the underlying token and transfers to/from the Panoptic Pool.
    /// @param data The encoded data containing the account and delta
    /// @return This function returns no data
    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        if (msg.sender != address(POOL_MANAGER_V4)) revert Errors.UnauthorizedUniswapCallback();

        (address account, int256 delta) = abi.decode(data, (address, int256));

        address underlyingToken = _underlyingToken();
        if (delta > 0) {
            POOL_MANAGER_V4.sync(Currency.wrap(underlyingToken));
            SafeTransferLib.safeTransferFrom(
                underlyingToken,
                account,
                address(POOL_MANAGER_V4),
                uint256(delta)
            );
            POOL_MANAGER_V4.settle();

            POOL_MANAGER_V4.mint(
                address(_panopticPool()),
                uint160(underlyingToken),
                uint256(delta)
            );
        } else if (delta < 0) {
            unchecked {
                delta = -delta;
            }
            POOL_MANAGER_V4.burn(
                address(_panopticPool()),
                uint160(underlyingToken),
                uint256(delta)
            );
            POOL_MANAGER_V4.take(Currency.wrap(underlyingToken), account, uint256(delta));
        }

        return "";
    }

    /*//////////////////////////////////////////////////////////////
                     STANDARD ERC4626 INTERFACE
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the token contract address of the underlying asset being managed.
    /// @return assetTokenAddress The address of the underlying asset
    function asset() external pure returns (address assetTokenAddress) {
        return _underlyingToken();
    }

    /// @notice Get the total amount of assets managed by the CollateralTracker vault.
    /// @dev This returns the total tracked assets in the AMM and PanopticPool,
    /// @dev - EXCLUDING the amount of collected fees (because they are reserved for short options)
    /// @dev - EXCLUDING any donations that have been made to the pool
    /// @return The total amount of assets managed by the CollateralTracker vault
    function totalAssets() public view returns (uint256) {
        unchecked {
            return uint256(s_poolAssets) + s_inAMM;
        }
    }

    /// @notice Returns the amount of shares that can be minted for the given amount of assets.
    /// @param assets The amount of assets to be deposited
    /// @return shares The amount of shares that can be minted
    function convertToShares(uint256 assets) public view returns (uint256 shares) {
        return Math.mulDiv(assets, totalSupply, totalAssets());
    }

    /// @notice Returns the amount of assets that can be redeemed for the given amount of shares.
    /// @param shares The amount of shares to be redeemed
    /// @return assets The amount of assets that can be redeemed
    function convertToAssets(uint256 shares) public view returns (uint256 assets) {
        return Math.mulDiv(shares, totalAssets(), totalSupply);
    }

    /// @notice Returns the maximum deposit amount.
    /// @return maxAssets The maximum amount of assets that can be deposited
    function maxDeposit(address) external pure returns (uint256 maxAssets) {
        return type(uint104).max;
    }

    /// @notice Returns shares received for depositing given amount of assets.
    /// @param assets The amount of assets to be deposited
    /// @return shares The amount of shares that can be minted
    function previewDeposit(uint256 assets) public view returns (uint256 shares) {
        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
        unchecked {
            shares = Math.mulDiv(
                assets * (DECIMALS - COMMISSION_FEE),
                totalSupply,
                totalAssets() * DECIMALS
            );
        }
    }

    /// @notice Deposit underlying tokens (assets) to the Panoptic pool from the LP and mint corresponding amount of shares.
    /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
    /// @dev An "MEV tax" is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
    /// @dev Shares are minted and sent to the LP (`receiver`).
    /// @param assets Amount of assets deposited
    /// @param receiver User to receive the shares
    /// @return shares The amount of Panoptic pool shares that were minted to the recipient
    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {
        if (assets > type(uint104).max) revert Errors.DepositTooLarge();

        shares = previewDeposit(assets);

        // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
        // in return for the shares to be minted
        _settleTokenDelta(msg.sender, int256(assets));

        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        s_poolAssets += uint128(assets);

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns the maximum shares received for a deposit.
    /// @return maxShares The maximum amount of shares that can be minted
    function maxMint(address) external view returns (uint256 maxShares) {
        unchecked {
            return (convertToShares(type(uint104).max) * (DECIMALS - COMMISSION_FEE)) / DECIMALS;
        }
    }

    /// @notice Returns the amount of assets that would be deposited to mint a given amount of shares.
    /// @param shares The amount of shares to be minted
    /// @return assets The amount of assets required to mint `shares`
    function previewMint(uint256 shares) public view returns (uint256 assets) {
        // round up depositing assets to avoid protocol loss
        // This prevents minting of shares where the assets provided is rounded down to zero
        // compute the MEV tax, which is equal to a single payment of the commissionRate on the FINAL (post mev-tax) assets paid
        // finalAssets - convertedAssets = commissionRate * finalAssets
        // finalAssets - commissionRate * finalAssets = convertedAssets
        // finalAssets * (1 - commissionRate) = convertedAssets
        // finalAssets = convertedAssets / (1 - commissionRate)
        assets = Math.mulDivRoundingUp(
            shares * DECIMALS,
            totalAssets(),
            totalSupply * (DECIMALS - COMMISSION_FEE)
        );
    }

    /// @notice Deposit required amount of assets to receive specified amount of shares.
    /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
    /// An "MEV tax" is levied, which is equal to a single payment of the commissionRate BEFORE adding the funds.
    /// @dev Shares are minted and sent to the LP (`receiver`).
    /// @param shares Amount of shares to be minted
    /// @param receiver User to receive the shares
    /// @return assets The amount of assets deposited to mint the desired amount of shares
    function mint(uint256 shares, address receiver) external returns (uint256 assets) {
        assets = previewMint(shares);

        if (assets > type(uint104).max) revert Errors.DepositTooLarge();

        // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
        // in return for the shares to be minted
        _settleTokenDelta(msg.sender, int256(assets));

        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        s_poolAssets += uint128(assets);

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns The maximum amount of assets that can be withdrawn for a given user.
    /// If the user has any open positions, the max withdrawable balance is zero.
    /// @dev Calculated from the balance of the user; limited by the assets the pool has available.
    /// @param owner The address being withdrawn for
    /// @return maxAssets The maximum amount of assets that can be withdrawn
    function maxWithdraw(address owner) public view returns (uint256 maxAssets) {
        uint256 poolAssets = s_poolAssets;
        unchecked {
            uint256 available = poolAssets > 0 ? poolAssets - 1 : 0;
            uint256 balance = convertToAssets(balanceOf[owner]);
            return _panopticPool().numberOfPositions(owner) == 0 ? Math.min(available, balance) : 0;
        }
    }

    /// @notice Returns the amount of shares that would be burned to withdraw a given amount of assets.
    /// @param assets The amount of assets to be withdrawn.
    /// @return shares The amount of shares that would be burned.
    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return Math.mulDivRoundingUp(assets, supply, totalAssets());
    }

    /// @notice Redeem the amount of shares required to withdraw the specified amount of assets.
    /// @dev We can only use this standard 4626 withdraw function if the user has no open positions.
    /// @dev Shares are burned and assets are sent to the LP (`receiver`).
    /// @param assets Amount of assets to be withdrawn
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @return shares The amount of shares burned to withdraw the desired amount of assets
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256 shares) {
        if (assets > maxWithdraw(owner)) revert Errors.ExceedsMaximumRedemption();

        shares = previewWithdraw(assets);

        // check/update allowance for approved withdraw
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets -= uint128(assets);
        }

        // transfer assets (underlying token funds) from the PanopticPool to the LP
        unchecked {
            _settleTokenDelta(receiver, -int256(assets));
        }

        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /// @notice Redeem the amount of shares required to withdraw the specified amount of assets.
    /// @dev Reverts if the account is not solvent with the given `positionIdList`.
    /// @dev Shares are burned and assets are sent to the LP (`receiver`).
    /// @param assets Amount of assets to be withdrawn
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @param positionIdList The list of all option positions held by `owner`
    /// @return shares The amount of shares burned to withdraw the desired amount of assets
    function withdraw(
        uint256 assets,
        address receiver,
        address owner,
        TokenId[] calldata positionIdList
    ) external returns (uint256 shares) {
        shares = previewWithdraw(assets);

        // check/update allowance for approved withdraw
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        s_poolAssets -= uint128(assets);

        // reverts if account is not solvent/eligible to withdraw
        _panopticPool().validateCollateralWithdrawable(owner, positionIdList);

        // transfer assets (underlying token funds) from the PanopticPool to the LP
        unchecked {
            _settleTokenDelta(receiver, -int256(assets));
        }

        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /// @notice Returns the maximum amount of shares that can be redeemed for a given user.
    /// If the user has any open positions, the max redeemable balance is zero.
    /// @param owner The redeeming address
    /// @return maxShares The maximum amount of shares that can be redeemed by `owner`
    function maxRedeem(address owner) public view returns (uint256 maxShares) {
        uint256 poolAssets = s_poolAssets;
        unchecked {
            uint256 available = convertToShares(poolAssets > 0 ? poolAssets - 1 : 0);
            uint256 balance = balanceOf[owner];
            return _panopticPool().numberOfPositions(owner) == 0 ? Math.min(available, balance) : 0;
        }
    }

    /// @notice Returns the amount of assets resulting from a given amount of shares being redeemed.
    /// @param shares The amount of shares to be redeemed
    /// @return assets The amount of assets resulting from the redemption
    function previewRedeem(uint256 shares) public view returns (uint256 assets) {
        return convertToAssets(shares);
    }

    /// @notice Redeem exact shares for underlying assets.
    /// @dev We can only use this standard 4626 redeem function if the user has no open positions.
    /// @param shares Amount of shares to be redeemed
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @return assets The amount of assets resulting from the redemption
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256 assets) {
        if (shares > maxRedeem(owner)) revert Errors.ExceedsMaximumRedemption();

        // check/update allowance for approved redeem
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;
        }

        assets = previewRedeem(shares);

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        unchecked {
            s_poolAssets -= uint128(assets);
        }

        // transfer assets (underlying token funds) from the PanopticPool to the LP
        unchecked {
            _settleTokenDelta(receiver, -int256(assets));
        }

        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /*//////////////////////////////////////////////////////////////
                        ACCOUNTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the cost of exercising an option. Used during a forced exercise.
    /// @notice This one computes the cost of calling the forceExercise function on a position:
    /// - The forceExercisor will have to *pay* the exercisee because their position will be closed "against their will"
    /// - The cost must be larger when the position is close to being in-range, and should be minimal when it is far from being in range. eg. Exercising a (1000, 1050)
    ///   position will cost more if the price is 999 than if it is 100
    /// - The cost is an exponentially decaying function of the distance between the position's strike and the current price
    /// - The cost decreases by a factor of 2 for every "position's width"
    /// - Note that the cost is the largest among all active legs, not the sum
    /// @notice Example exercise costs:
    /// - 10% if the position is liquidated when the price is between 950 and 1000, or if it is between 1050 and 1100
    /// - 5% if the price is between 900 and 950 or (1100, 1150)
    /// - 2.5% if between (850, 900) or (1150, 1200)
    /// @param currentTick The current price tick
    /// @param oracleTick The price oracle tick
    /// @param positionId The position to be exercised
    /// @param positionSize The size of the position to be exercised
    /// @param longAmounts The amount of longs in the position
    /// @return exerciseFees The fees for exercising the option position
    function exerciseCost(
        int24 currentTick,
        int24 oracleTick,
        TokenId positionId,
        uint128 positionSize,
        LeftRightSigned longAmounts
    ) external view returns (LeftRightSigned exerciseFees) {
        // find the leg furthest to the strike price `currentTick`; this will have the lowest exercise cost
        // we don't need the leg information itself, really just "the number of half ranges" from the strike price:
        uint256 maxNumRangesFromStrike = 1; // technically "maxNum(Half)RangesFromStrike" but the name is long

        unchecked {
            for (uint256 leg = 0; leg < positionId.countLegs(); ++leg) {
                // short legs are not counted - exercise is intended to be based on long legs
                if (positionId.isLong(leg) == 0) continue;

                {
                    int24 range = int24(
                        int256(
                            Math.unsafeDivRoundingUp(
                                uint24(positionId.width(leg) * positionId.tickSpacing()),
                                2
                            )
                        )
                    );
                    maxNumRangesFromStrike = Math.max(
                        maxNumRangesFromStrike,
                        uint256(Math.abs(currentTick - positionId.strike(leg)) / range)
                    );
                }

                uint256 currentValue0;
                uint256 currentValue1;
                uint256 oracleValue0;
                uint256 oracleValue1;

                {
                    LiquidityChunk liquidityChunk = PanopticMath.getLiquidityChunk(
                        positionId,
                        leg,
                        positionSize
                    );

                    (currentValue0, currentValue1) = Math.getAmountsForLiquidity(
                        currentTick,
                        liquidityChunk
                    );

                    (oracleValue0, oracleValue1) = Math.getAmountsForLiquidity(
                        oracleTick,
                        liquidityChunk
                    );
                }

                // reverse any token deltas between the current and oracle prices for the chunk the exercisee had to mint in Uniswap
                // the outcome of current price crossing a long chunk will always be less favorable than the status quo, i.e.,
                // if the current price is moved downward such that some part of the chunk is between the current and market prices,
                // the chunk composition will swap token1 for token0 at a price (token0/token1) more favorable than market (token1/token0),
                // forcing the exercisee to provide more value in token0 than they would have provided in token1 at market, and vice versa.
                // (the excess value provided by the exercisee could then be captured in a return swap across their newly added liquidity)
                exerciseFees = exerciseFees.sub(
                    LeftRightSigned
                        .wrap(0)
                        .toRightSlot(int128(uint128(currentValue0)) - int128(uint128(oracleValue0)))
                        .toLeftSlot(int128(uint128(currentValue1)) - int128(uint128(oracleValue1)))
                );
            }

            // NOTE: we HAVE to start with a negative number as the base exercise cost because when shifting a negative number right by n bits,
            // the result is rounded DOWN and NOT toward zero
            // this divergence is observed when n (the number of half ranges) is > 10 (ensuring the floor is not zero, but -1 = 1bps at that point)
            // subtract 1 from max half ranges from strike so fee starts at FORCE_EXERCISE_COST when moving OTM
            int256 fee = (FORCE_EXERCISE_COST >> (maxNumRangesFromStrike - 1)); // exponential decay of fee based on number of half ranges away from the price

            // store the exercise fees in the exerciseFees variable
            exerciseFees = exerciseFees
                .toRightSlot(int128((longAmounts.rightSlot() * fee) / DECIMALS_128))
                .toLeftSlot(int128((longAmounts.leftSlot() * fee) / DECIMALS_128));
        }
    }

    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
    /// @return poolUtilization The pool utilization in basis points
    function _poolUtilization() internal view returns (uint256 poolUtilization) {
        unchecked {
            return (s_inAMM * DECIMALS) / totalAssets();
        }
    }

    /// @notice Get the base collateral requirement for a short leg at a given pool utilization.
    /// @dev This is computed at the time the position is minted.
    /// @param utilization The pool utilization of this collateral vault at the time the position is minted
    /// @return sellCollateralRatio The sell collateral ratio at `utilization`
    function _sellCollateralRatio(
        int256 utilization
    ) internal view returns (uint256 sellCollateralRatio) {
        // the sell ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
        //   (x0,y0) = (targetPoolUtilization,min_sell_ratio) and
        //   (x1,y1) = (saturatedPoolUtilization,max_sell_ratio)
        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
        /*
            SELL
            COLLATERAL
            RATIO
                          ^
                          |                  max ratio = 100%
                   100% - |                _------
                          |             _-¯
                          |          _-¯
                    20% - |---------¯
                          |         .       . .
                          +---------+-------+-+--->   POOL_
                                   50%    90% 100%     UTILIZATION
        */

        uint256 min_sell_ratio = SELLER_COLLATERAL_RATIO;
        /// if utilization is less than zero, this is the calculation for a strangle, which gets 2x the capital efficiency at low pool utilization
        /// at 0% utilization, strangle legs do not compound efficiency
        if (utilization < 0) {
            unchecked {
                min_sell_ratio /= 2;
                utilization = -utilization;
            }
        }

        // return the basal sell ratio if pool utilization is lower than target
        if (uint256(utilization) < TARGET_POOL_UTIL) {
            return min_sell_ratio;
        }

        // return 100% collateral ratio if utilization is above saturated pool utilization
        // this means all new positions are fully collateralized, which reduces risks of insolvency at high pool utilization
        if (uint256(utilization) > SATURATED_POOL_UTIL) {
            return DECIMALS;
        }

        unchecked {
            return
                min_sell_ratio +
                ((DECIMALS - min_sell_ratio) * (uint256(utilization) - TARGET_POOL_UTIL)) /
                (SATURATED_POOL_UTIL - TARGET_POOL_UTIL);
        }
    }

    /// @notice Get the base collateral requirement for a long leg at a given pool utilization.
    /// @dev This is computed at the time the position is minted.
    /// @param utilization The pool utilization of this collateral vault at the time the position is minted
    /// @return buyCollateralRatio The buy collateral ratio at `utilization`
    function _buyCollateralRatio(
        uint16 utilization
    ) internal view returns (uint256 buyCollateralRatio) {
        // linear from BUY to BUY/2 between 50% and 90%
        // the buy ratio is on a straight line defined between two points (x0,y0) and (x1,y1):
        //   (x0,y0) = (targetPoolUtilization,buyCollateralRatio) and
        //   (x1,y1) = (saturatedPoolUtilization,buyCollateralRatio / 2)
        // note that y1<y0 so the slope is negative:
        // aka the buy ratio starts high and drops to a lower value with increased utilization; the sell ratio does the opposite (slope is positive)
        // the line's formula: y = a * (x - x0) + y0, where a = (y1 - y0) / (x1 - x0)
        // but since a<0, we rewrite as:
        // y = a' * (x0 - x) + y0, where a' = (y0 - y1) / (x1 - x0)

        // HOWEVER, if the utilization is larger than 10_000, then default to 100% buying power requirement.
        // this denotes a situation where the median is too far away from the current price, so we need to require fully collateralized positions for safety
        /*
          BUY
          COLLATERAL
          RATIO
                 ^
                 |   buy_ratio = 10%
           10% - |----------__       min_ratio = 5%
           5%  - | . . . . .  ¯¯¯--______
                 |         .       . .
                 +---------+-------+-+--->   POOL_
                          50%    90% 100%      UTILIZATION
         */

        // return the basal buy ratio if pool utilization is lower than target
        if (utilization < TARGET_POOL_UTIL) {
            return BUYER_COLLATERAL_RATIO;
        }

        // return the basal ratio divided by 2 if pool utilization is above saturated pool utilization
        /// this is incentivized buying, which returns funds to the panoptic pool
        if (utilization > SATURATED_POOL_UTIL) {
            unchecked {
                return BUYER_COLLATERAL_RATIO / 2;
            }
        }

        unchecked {
            return
                (BUYER_COLLATERAL_RATIO +
                    (BUYER_COLLATERAL_RATIO * (SATURATED_POOL_UTIL - utilization)) /
                    (SATURATED_POOL_UTIL - TARGET_POOL_UTIL)) / 2; // do the division by 2 at the end after all addition and multiplication; b/c y1 = buyCollateralRatio / 2
        }
    }

    /*////////////////////////////////////////////////////////////////////
          LIFECYCLE OF A COLLATERAL TOKEN AND DELEGATE/REVOKE LOGIC
    ////////////////////////////////////////////////////////////////////*/

    /// @notice Increase the share balance of a user by `2^248 - 1` without updating the total supply.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @param delegatee The account to increase the balance of
    function delegate(address delegatee) external onlyPanopticPool {
        balanceOf[delegatee] += type(uint248).max;
    }

    /// @notice Decrease the share balance of a user by `2^248 - 1` without updating the total supply.
    /// @dev Assumes that `delegatee` has `>=(2^248 - 1)` tokens, will revert otherwise.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @param delegatee The account to decrease the balance of
    function revoke(address delegatee) external onlyPanopticPool {
        balanceOf[delegatee] -= type(uint248).max;
    }

    /// @notice Settles liquidation bonus and returns remaining virtual shares to the protocol.
    /// @dev This function is where protocol loss is realized, if it exists.
    /// @param liquidator The account performing the liquidation of `liquidatee`
    /// @param liquidatee The liquidated account to settle
    /// @param bonus The liquidation bonus, in assets, to be paid to `liquidator`. May be negative
    function settleLiquidation(
        address liquidator,
        address liquidatee,
        int256 bonus
    ) external onlyPanopticPool {
        if (bonus < 0) {
            uint256 bonusAbs;

            unchecked {
                bonusAbs = uint256(-bonus);
            }

            _settleTokenDelta(liquidator, int256(bonusAbs));

            _mint(liquidatee, convertToShares(bonusAbs));

            s_poolAssets += uint128(bonusAbs);

            uint256 liquidateeBalance = balanceOf[liquidatee];

            if (type(uint248).max > liquidateeBalance) {
                balanceOf[liquidatee] = 0;
                unchecked {
                    totalSupply += type(uint248).max - liquidateeBalance;
                }
            } else {
                unchecked {
                    balanceOf[liquidatee] = liquidateeBalance - type(uint248).max;
                }
            }
        } else {
            uint256 liquidateeBalance = balanceOf[liquidatee];

            if (type(uint248).max > liquidateeBalance) {
                unchecked {
                    totalSupply += type(uint248).max - liquidateeBalance;
                }
                liquidateeBalance = 0;
            } else {
                unchecked {
                    liquidateeBalance -= type(uint248).max;
                }
            }

            balanceOf[liquidatee] = liquidateeBalance;

            uint256 bonusShares = convertToShares(uint256(bonus));

            // if requested amount is larger than user balance, transfer their balance and mint the remaining shares
            if (bonusShares > liquidateeBalance) {
                _transferFrom(liquidatee, liquidator, liquidateeBalance);

                // this is paying out protocol loss, so correct for that in the amount of shares to be minted
                // X: total assets in vault
                // Y: total supply of shares
                // Z: desired value (assets) of shares to be minted
                // N: total shares corresponding to Z
                // T: transferred shares from liquidatee which are a component of N but do not contribute toward protocol loss
                // Z = N * X / (Y + N - T)
                // Z * (Y + N - T) = N * X
                // ZY + ZN - ZT = NX
                // ZY - ZT = N(X - Z)
                // N = (ZY - ZT) / (X - Z)
                // N = Z(Y - T) / (X - Z)
                // subtract delegatee balance from N since it was already transferred to the delegator
                uint256 _totalSupply = totalSupply;
                unchecked {
                    _mint(
                        liquidator,
                        Math.min(
                            Math.mulDivCapped(
                                uint256(bonus),
                                _totalSupply - liquidateeBalance,
                                uint256(Math.max(1, int256(totalAssets()) - bonus))
                            ) - liquidateeBalance,
                            _totalSupply * DECIMALS
                        )
                    );
                }
            } else {
                _transferFrom(liquidatee, liquidator, bonusShares);
            }
        }
    }

    /// @notice Refunds delegated tokens to `refunder` from `refundee`, similar to `revoke`.
    /// @dev Assumes that the refunder has enough money to pay for the refund.
    /// @dev Can handle negative refund amounts that go from refundee to refunder in the case of high exercise fees.
    /// @param refunder The account refunding tokens to `refundee`
    /// @param refundee The account being refunded to
    /// @param assets The amount of assets to refund. Positive means a transfer from refunder to refundee, vice versa for negative
    function refund(address refunder, address refundee, int256 assets) external onlyPanopticPool {
        if (assets > 0) {
            _transferFrom(refunder, refundee, convertToShares(uint256(assets)));
        } else {
            unchecked {
                _transferFrom(refundee, refunder, convertToShares(uint256(-assets)));
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                     OPTION EXERCISE AND COMMISSION
    //////////////////////////////////////////////////////////////*/

    /// @notice Take commission on option creation/opening (commissions will not be taken on closing).
    /// @param optionOwner The user minting the option
    /// @param longAmount The amount of longs
    /// @param shortAmount The amount of shorts
    /// @param swappedAmount The amount of tokens moved during creation of the option position
    /// @param isCovered Whether the option was minted as covered (no swap occured if ITM)
    /// @return utilization The final utilization of the collateral vault
    function takeCommissionAddData(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount,
        bool isCovered
    ) external onlyPanopticPool returns (uint32 utilization) {
        unchecked {
            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;

            // constrict premium to only assets not belonging to PLPs (i.e premium paid by sellers or collected from the pool earlier)
            int256 tokenToPay = _getExchangedAmount(
                longAmount,
                shortAmount,
                swappedAmount,
                isCovered
            );

            // compute tokens to be paid due to swap
            // mint or burn tokens due to minting in-the-money
            if (tokenToPay > 0) {
                // if user must pay tokens, burn them from user balance
                uint256 sharesToBurn = Math.mulDivRoundingUp(
                    uint256(tokenToPay),
                    totalSupply,
                    totalAssets()
                );
                _burn(optionOwner, sharesToBurn);
            } else if (tokenToPay < 0) {
                // if user must receive tokens, mint them
                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
                _mint(optionOwner, sharesToMint);
            }

            // update stored asset balances with net moved amounts
            // the inflow or outflow of pool assets is defined by the swappedAmount: it includes both the ITM swap amounts and the short/long amounts used to create the position
            // however, any intrinsic value is paid for by the users, so we only add the portion that comes from PLPs: the short/long amounts
            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
            s_poolAssets = uint256(updatedAssets).toUint128();
            s_inAMM = uint256(int256(uint256(s_inAMM)) + (shortAmount - longAmount)).toUint128();

            utilization = uint32(_poolUtilization());
        }
    }

    /// @notice Exercise an option and pay to the seller what is owed from the buyer.
    /// @dev Called when a position is burnt because it may need to be exercised.
    /// @param optionOwner The owner of the option being burned and potentially exercised
    /// @param longAmount The notional value of the long legs of the position (if any)
    /// @param shortAmount The notional value of the short legs of the position (if any)
    /// @param swappedAmount The amount of tokens moved during the option close
    /// @param realizedPremium Premium to settle on the current positions
    /// @return The amount of tokens paid when closing that position
    function exercise(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount,
        int128 realizedPremium
    ) external onlyPanopticPool returns (int128) {
        unchecked {
            // current available assets belonging to PLPs (updated after settlement) excluding any premium paid
            int256 updatedAssets = int256(uint256(s_poolAssets)) - swappedAmount;

            // add premium and token deltas not covered by swap to be paid/collected on position close
            int256 tokenToPay = int256(swappedAmount) -
                (longAmount - shortAmount) -
                realizedPremium;

            if (tokenToPay > 0) {
                // if user must pay tokens, burn them from user balance (revert if balance too small)
                uint256 sharesToBurn = Math.mulDivRoundingUp(
                    uint256(tokenToPay),
                    totalSupply,
                    totalAssets()
                );
                _burn(optionOwner, sharesToBurn);
            } else if (tokenToPay < 0) {
                // if user must receive tokens, mint them
                uint256 sharesToMint = convertToShares(uint256(-tokenToPay));
                _mint(optionOwner, sharesToMint);
            }

            // update stored asset balances with net moved amounts
            // any intrinsic value is paid for by the users, so we do not add it to s_inAMM
            // premia is not included in the balance since it is the property of options buyers and sellers, not PLPs
            s_poolAssets = uint256(updatedAssets + realizedPremium).toUint128();
            s_inAMM = uint256(int256(uint256(s_inAMM)) - (shortAmount - longAmount)).toUint128();

            return (int128(tokenToPay));
        }
    }

    /// @notice Get the amount exchanged to mint an option.
    /// @param longAmount The amount of long options held
    /// @param shortAmount The amount of short options held
    /// @param swappedAmount The amount of tokens moved during creation of the option position
    /// @param isCovered Whether the option was minted as covered (no swap occured if ITM)
    /// @return exchangedAmount The amount of funds to be exchanged for minting an option (includes commission, swapFee, and intrinsic value)
    function _getExchangedAmount(
        int128 longAmount,
        int128 shortAmount,
        int128 swappedAmount,
        bool isCovered
    ) internal view returns (int256 exchangedAmount) {
        unchecked {
            // add the intrinsic value (amount that needs to be exchanged due to minting in-the-money)
            exchangedAmount = int256(swappedAmount) - (shortAmount - longAmount);

            // the swap commission is paid on the intrinsic value (if a swap occured -- users who mint covered options with their own collateral do not pay this fee)
            if (!isCovered)
                exchangedAmount += int256(
                    Math.unsafeDivRoundingUp(
                        ITM_SPREAD_FEE * uint256(Math.abs(exchangedAmount)),
                        DECIMALS
                    )
                );

            // total commission rate = notional value * COMMISSION_FEE + intrinsic value (swapped) * ITM_SPREAD_FEE
            exchangedAmount += int256(
                Math.unsafeDivRoundingUp(
                    uint256(uint128(shortAmount + longAmount)) * COMMISSION_FEE,
                    DECIMALS
                )
            );
        }
    }

    /*//////////////////////////////////////////////////////////////
                     HEALTH AND COLLATERAL TRACKING
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the collateral status/margin details of an account/user.
    /// @dev NOTE: It's up to the caller to confirm from the returned result that the account has enough collateral.
    /// @dev This can be used to check the health: how many tokens a user has compared to the margin threshold.
    /// @param user The account to check collateral/margin health for
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param positionBalanceArray The list of all historical positions held by the `optionOwner`, stored as `[[tokenId, balance/poolUtilizationAtMint], ...]`
    /// @param shortPremium The total amount of premium (prorated by available settled tokens) owed to the short legs of `user`
    /// @param longPremium The total amount of premium owed by the long legs of `user`
    /// @return Information collected for the tokens about the health of the account
    /// The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot.
    function getAccountMarginDetails(
        address user,
        int24 atTick,
        uint256[2][] memory positionBalanceArray,
        uint128 shortPremium,
        uint128 longPremium
    ) public view returns (LeftRightUnsigned) {
        unchecked {
            return
                LeftRightUnsigned
                    .wrap((convertToAssets(balanceOf[user]) + shortPremium).toUint128())
                    .toLeftSlot(
                        positionBalanceArray.length > 0
                            ? (_getTotalRequiredCollateral(atTick, positionBalanceArray) +
                                longPremium).toUint128()
                            : 0
                    );
        }
    }

    /// @notice Get the total required amount of collateral tokens of a user/account across all active positions to stay above the margin requirement.
    /// @dev Returns the token amounts required for the entire account with active positions in `positionIdList` (list of tokenIds).
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param positionBalanceArray The list of all historical positions held by the `optionOwner`, stored as `[[tokenId, balance/poolUtilizationAtMint], ...]`
    /// @return tokenRequired The amount of tokens required to stay above the margin threshold for all active positions of user
    function _getTotalRequiredCollateral(
        int24 atTick,
        uint256[2][] memory positionBalanceArray
    ) internal view returns (uint256 tokenRequired) {
        // loop through each active position.
        // Offset determined whether to consider the last tokenId from the list
        // (a potentially newly minted position)
        uint256 totalIterations = positionBalanceArray.length;
        for (uint256 i = 0; i < totalIterations; ) {
            // read the ith tokenId from the account
            TokenId tokenId = TokenId.wrap(positionBalanceArray[i][0]);

            // read the position size and the pool utilization at mint
            uint128 positionSize = PositionBalance.wrap(positionBalanceArray[i][1]).positionSize();

            bool underlyingIsToken0 = _underlyingIsToken0();

            // read the pool utilization at mint
            int16 poolUtilization = underlyingIsToken0
                ? int16(PositionBalance.wrap(positionBalanceArray[i][1]).utilization0())
                : int16(PositionBalance.wrap(positionBalanceArray[i][1]).utilization1());

            // Get tokens required for the current tokenId (a single active position)
            uint256 _tokenRequired = _getRequiredCollateralAtTickSinglePosition(
                tokenId,
                positionSize,
                atTick,
                poolUtilization,
                underlyingIsToken0
            );

            // add to the tokenRequired accumulator
            unchecked {
                tokenRequired += _tokenRequired;
            }
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Get the required amount of collateral tokens corresponding to a specific single position `tokenId` at a price `atTick`.
    /// The required collateral of an account depends on the price (`atTick`) in the AMM pool: if in the position's favor less collateral needed, etc.
    /// @param tokenId The option position
    /// @param positionSize The size of the option position
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param poolUtilization The utilization of the collateral vault (balance of buying and selling)
    /// @param underlyingIsToken0 Cached `_underlyingIsToken0()` value for this CollateralTracker instance
    /// @return tokenRequired Total required tokens for all legs of the specified tokenId.
    function _getRequiredCollateralAtTickSinglePosition(
        TokenId tokenId,
        uint128 positionSize,
        int24 atTick,
        int16 poolUtilization,
        bool underlyingIsToken0
    ) internal view returns (uint256 tokenRequired) {
        uint256 numLegs = tokenId.countLegs();

        unchecked {
            for (uint256 index = 0; index < numLegs; ++index) {
                // revert if the tokenType does not match the current collateral token
                if (tokenId.tokenType(index) != (underlyingIsToken0 ? 0 : 1)) continue;
                // Increment the tokenRequired accumulator
                tokenRequired += _getRequiredCollateralSingleLeg(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
            }
        }
    }

    /// @notice Calculate the required amount of collateral for a single leg `index` of position `tokenId`.
    /// @param tokenId The option position
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
    /// @param positionSize The size of the position
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
    /// @return required The required amount collateral needed for this leg `index`
    function _getRequiredCollateralSingleLeg(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        int16 poolUtilization
    ) internal view returns (uint256 required) {
        return
            tokenId.riskPartner(index) == index // does this leg have a risk partner? Affects required collateral
                ? _getRequiredCollateralSingleLegNoPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                )
                : _getRequiredCollateralSingleLegPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
    }

    /// @notice Calculate the required amount of collateral for leg `index` of position `tokenId` when the leg does not have a risk partner.
    /// @param tokenId The option position
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
    /// @param positionSize The size of the position
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param poolUtilization The pool utilization: ratio of how much funds are in the Panoptic pool versus the AMM pool
    /// @return required The required amount collateral needed for this leg `index`
    function _getRequiredCollateralSingleLegNoPartner(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        int16 poolUtilization
    ) internal view returns (uint256 required) {
        // extract the tokenType (token0 or token1)
        uint256 tokenType = tokenId.tokenType(index);

        // compute the total amount of funds moved for that position
        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);

        // amount moved is right slot if tokenType=0, left slot otherwise
        uint128 amountMoved = tokenType == 0 ? amountsMoved.rightSlot() : amountsMoved.leftSlot();

        uint256 isLong = tokenId.isLong(index);

        // start with base requirement, which is based on isLong value
        required = _getRequiredCollateralAtUtilization(amountMoved, isLong, poolUtilization);

        // if the position is long, required tokens does not depend on price
        unchecked {
            if (isLong == 0) {
                // if position is short, check whether the position is out-the-money

                (int24 tickLower, int24 tickUpper) = tokenId.asTicks(index);

                // compute the collateral requirement as a fixed amount that doesn't depend on price
                if (
                    ((atTick >= tickUpper) && (tokenType == 1)) || // strike OTM when price >= upperTick for tokenType=1
                    ((atTick < tickLower) && (tokenType == 0)) // strike OTM when price < lowerTick for tokenType=0
                ) {
                    // position is out-the-money, collateral requirement = SCR * amountMoved
                    required;
                } else {
                    int24 strike = tokenId.strike(index);
                    // if position is ITM or ATM, then the collateral requirement depends on price:

                    // compute the ratio of strike to price for calls (or price to strike for puts)
                    // (- and * 2 in tick space are / and ^ 2 in price space so sqrtRatioAtTick(2 *(a - b)) = a/b (*2^96)
                    // both of these ratios decrease as the position becomes deeper ITM, and it is possible
                    // for the ratio of the prices to go under the minimum price
                    // (which is the limit of what getSqrtRatioAtTick supports)
                    // so instead we cap it at the minimum price, which is acceptable because
                    // a higher ratio will result in an increased slope for the collateral requirement
                    uint160 ratio = tokenType == 1 // tokenType
                        ? Math.getSqrtRatioAtTick(
                            Math.max24(2 * (atTick - strike), Constants.MIN_V4POOL_TICK)
                        ) // puts ->  price/strike
                        : Math.getSqrtRatioAtTick(
                            Math.max24(2 * (strike - atTick), Constants.MIN_V4POOL_TICK)
                        ); // calls -> strike/price

                    // compute the collateral requirement depending on whether the position is ITM & out-of-range or ITM and in-range:

                    /// ITM and out-of-range
                    if (
                        ((atTick < tickLower) && (tokenType == 1)) || // strike ITM but out of range price < lowerTick for tokenType=1
                        ((atTick >= tickUpper) && (tokenType == 0)) // strike ITM but out of range when price >= upperTick for tokenType=0
                    ) {
                        /*
                                    Short put BPR = 100% - (price/strike) + SCR

                           BUYING
                           POWER
                           REQUIREMENT
                         
                                         ^               .         .
                                         |        <- ITM . <-ATM-> . OTM ->
                           100% + SCR% - |--__           .    .    .
                                  100% - | . .¯¯--__     .    .    .
                                         |    .     ¯¯--__    .    .
                                   SCR - |    .          .¯¯--__________
                                         |    .          .    .    .
                                         +----+----------+----+----+--->   current
                                         0   Liqui-     Pa  strike Pb       price
                                             dation
                                             price = SCR*strike                                         
                         */

                        uint256 c2 = Constants.FP96 - ratio;

                        // compute the tokens required
                        // position is in-the-money, collateral requirement = amountMoved*(1-ratio) + SCR*amountMoved
                        required += Math.mulDiv96RoundingUp(amountMoved, c2);
                    } else {
                        // position is in-range (ie. current tick is between upper+lower tick): we draw a line between the
                        // collateral requirement at the lowerTick and the one at the upperTick. We use that interpolation as
                        // the collateral requirement when in-range, which always over-estimates the amount of token required
                        // Specifically:
                        //  required = amountMoved * (scaleFactor - ratio) / (scaleFactor + 1) + sellCollateralRatio*amountMoved
                        uint160 scaleFactor = Math.getSqrtRatioAtTick(
                            (tickUpper - strike) + (strike - tickLower)
                        );
                        uint256 c3 = Math.mulDivRoundingUp(
                            amountMoved,
                            scaleFactor - ratio,
                            scaleFactor + Constants.FP96
                        );
                        // position is in-the-money, collateral requirement = amountMoved*(1-SRC)*(scaleFactor-ratio)/(scaleFactor+1) + SCR*amountMoved
                        required += c3;
                    }
                }
            }
        }
    }

    /// @notice Calculate the required amount of collateral for leg `index` for position `tokenId` accounting for its partner leg.
    /// @dev If the two token long-types are different (one is a long, the other a short, e.g.) but the tokenTypes are the same, this is a spread.
    /// @dev A spread is a defined risk position which has a max loss given by difference between the long and short strikes.
    /// @dev If the two token long-types are the same but the tokenTypes are different (one is a call, the other a put, e.g.), this is a strangle -
    /// a strangle benefits from enhanced capital efficiency because only one side can be ITM at any given time.
    /// @dev if the position is a spread, then the collateral requirement consists of two components:
    /// @dev 1) The difference in notional value at both strikes: `abs(strikeLong - strikeShort)` or `abs(strikeShort - strikeLong)`
    /// @dev 2) A spread term which is relevant for legs that have different widths (calendar spreads)
    /// @param tokenId The option position
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
    /// @param positionSize The size of the position
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
    /// @return required The required amount collateral needed for this leg `index`, accounting for what the leg's risk partner is
    function _getRequiredCollateralSingleLegPartner(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        int16 poolUtilization
    ) internal view returns (uint256 required) {
        // extract partner index (associated with another liquidity chunk)
        uint256 partnerIndex = tokenId.riskPartner(index);

        uint256 isLong = tokenId.isLong(index);
        if (isLong != tokenId.isLong(partnerIndex)) {
            if (isLong == 1) {
                // compute the total amount of funds moved for that position
                required = _computeSpread(
                    tokenId,
                    positionSize,
                    index,
                    partnerIndex,
                    poolUtilization
                );
            }
        } else {
            required = _computeStrangle(tokenId, index, positionSize, atTick, poolUtilization);
        }
    }

    /// @notice Get the base collateral requirement for a position of notional value `amount` at the current Panoptic pool `utilization` level.
    /// @param amount The amount to multiply by the base collateral ratio
    /// @param isLong Whether the position is long (=1) or short (=0)
    /// @param utilization The utilization of the Panoptic pool (balance between sellers and buyers)
    /// @return required The base collateral requirement corresponding to the incoming `amount`
    function _getRequiredCollateralAtUtilization(
        uint128 amount,
        uint256 isLong,
        int16 utilization
    ) internal view returns (uint256 required) {
        // if position is short, use sell collateral ratio
        if (isLong == 0) {
            // compute the sell collateral ratio, which depends on the pool utilization
            uint256 sellCollateral = _sellCollateralRatio(utilization);

            // compute required as amount*collateralRatio
            // can use unsafe because denominator is always nonzero
            unchecked {
                required = Math.unsafeDivRoundingUp(amount * sellCollateral, DECIMALS);
            }
        } else if (isLong == 1) {
            // if options is long, use buy collateral ratio
            // compute the buy collateral ratio, which depends on the pool utilization
            uint256 buyCollateral = _buyCollateralRatio(uint16(utilization));

            // compute required as amount*collateralRatio
            // can use unsafe because denominator is always nonzero
            unchecked {
                required = Math.unsafeDivRoundingUp(amount * buyCollateral, DECIMALS);
            }
        }
    }

    /// @notice Calculate the required amount of collateral for the spread portion of the spread position.
    /// @dev (long leg requirement + 100% collateralized risk)
    /// @dev May be higher than the requirement of non risk-partnered legs if the spread is very wide (risky).
    /// @param tokenId The option position
    /// @param positionSize The size of the position
    /// @param index The leg index of the LONG leg in the spread position
    /// @param partnerIndex The index of the partnered SHORT leg in the spread position
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
    /// @return spreadRequirement The required amount of collateral needed for the spread portion
    function _computeSpread(
        TokenId tokenId,
        uint128 positionSize,
        uint256 index,
        uint256 partnerIndex,
        int16 poolUtilization
    ) internal view returns (uint256 spreadRequirement) {
        // compute the total amount of funds moved for the position's current leg
        LeftRightUnsigned amountsMoved = PanopticMath.getAmountsMoved(tokenId, positionSize, index);

        // compute the total amount of funds moved for the position's partner leg
        LeftRightUnsigned amountsMovedPartner = PanopticMath.getAmountsMoved(
            tokenId,
            positionSize,
            partnerIndex
        );

        // amount moved is right slot if tokenType=0, left slot otherwise
        uint128 movedRight = amountsMoved.rightSlot();
        uint128 movedLeft = amountsMoved.leftSlot();

        // amounts moved for partner
        uint128 movedPartnerRight = amountsMovedPartner.rightSlot();
        uint128 movedPartnerLeft = amountsMovedPartner.leftSlot();

        uint256 tokenType = tokenId.tokenType(index);

        // compute the max loss of the spread

        // if asset is NOT the same as the tokenType, the required amount is simply the difference in notional values
        // ie. asset = 1, tokenType = 0:
        if (tokenId.asset(index) != tokenType) {
            unchecked {
                // always take the absolute values of the difference of amounts moved
                if (tokenType == 0) {
                    spreadRequirement = movedRight < movedPartnerRight
                        ? movedPartnerRight - movedRight
                        : movedRight - movedPartnerRight;
                } else {
                    spreadRequirement = movedLeft < movedPartnerLeft
                        ? movedPartnerLeft - movedLeft
                        : movedLeft - movedPartnerLeft;
                }
            }
        } else {
            unchecked {
                uint256 notional;
                uint256 notionalP;
                uint128 contracts;
                if (tokenType == 1) {
                    notional = movedRight;
                    notionalP = movedPartnerRight;
                    contracts = movedLeft;
                } else {
                    notional = movedLeft;
                    notionalP = movedPartnerLeft;
                    contracts = movedRight;
                }
                // the required amount is the amount of contracts multiplied by (notional1 - notional2)/min(notional1, notional2)
                // can use unsafe because denominator is always nonzero
                spreadRequirement = (notional < notionalP)
                    ? Math.unsafeDivRoundingUp((notionalP - notional) * contracts, notional)
                    : Math.unsafeDivRoundingUp((notional - notionalP) * contracts, notionalP);
            }
        }

        // calculate the spread requirement as max(max_loss, long_leg_col_req)
        // narrower spreads will be very capital efficient (1/3 of non-partnered CR!), but
        // wider spreads (an uncommon position w/ high max loss) may not benefit from risk partnering
        spreadRequirement = Math.max(
            spreadRequirement,
            _getRequiredCollateralAtUtilization(
                tokenType == 0 ? movedRight : movedLeft,
                1,
                poolUtilization
            )
        );
    }

    /// @notice Calculate the required amount of collateral for a strangle leg.
    /// @dev Strangle legs are evaluated at 2x capital efficiency at low pool utilizations.
    /// @dev A strangle can only have only one of its leg tested at the same time, so this reduces the total risk and collateral requirement.
    /// @param tokenId The option position
    /// @param positionSize The size of the position
    /// @param index The leg index (associated with a liquidity chunk) to consider a partner for
    /// @param atTick The tick at which to evaluate the account's positions
    /// @param poolUtilization The pool utilization: how much funds are in the Panoptic pool versus the AMM pool
    /// @return strangleRequired The required amount of collateral needed for the strangle leg
    function _computeStrangle(
        TokenId tokenId,
        uint256 index,
        uint128 positionSize,
        int24 atTick,
        int16 poolUtilization
    ) internal view returns (uint256 strangleRequired) {
        // If both tokenTypes are the same, then this is a long or short strangle.
        // A strangle is an options strategy in which the investor holds a position
        // in both a call and a put option with different strike prices,
        // but with the same expiration date and underlying asset.

        /// collateral requirement is for short strangles depicted:
        /**
                    Put side of a short strangle, BPR = 100% - (100% - SCR/2)*(price/strike)
           BUYING
           POWER
           REQUIREMENT
                         ^                    .
                         |           <- ITM   .  OTM ->
                  100% - |--__                .
                         |    ¯¯--__          .
                         |          ¯¯--__    .
                 SCR/2 - |                ¯¯--______ <------ base collateral is half that of a single-leg
                         +--------------------+--->   current
                         0                  strike     price
         */
        unchecked {
            // A negative pool utilization is used to denote a position which is a strangle
            // at low pool utilization's strangle legs are evaluated at 2x capital efficiency

            // add 1 to handle poolUtilization = 0
            poolUtilization = -(poolUtilization == 0 ? int16(1) : poolUtilization);

            return
                strangleRequired = _getRequiredCollateralSingleLegNoPartner(
                    tokenId,
                    index,
                    positionSize,
                    atTick,
                    poolUtilization
                );
        }
    }
}
